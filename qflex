#!/usr/bin/env python

import typer
from typing import Annotated
from commands.createimage import CreateImage
from commands.boot import Boot
from commands.load import Load
from commands.docker import DockerStarter, DockerBuild

app = typer.Typer(
    name="qflex cli",
    help="A CLI tool to manage QFlex operations. (suggest running ./qflex --show-completion >> ~/.bashrc && source ~/.bashrc to enable autocompletions)",
)


@app.command()
def build_docker(
    debug: Annotated[bool, typer.Option(help="Build the Docker image in debug mode.")] = False,
):
    """
    Build the Docker image for QFlex. Use --debug to build a debug version.
    Useful for development and testing without installing dependencies locally.
    """
    docker_build_executor = DockerBuild(debug=debug)
    docker_build_executor.execute(to_stdio=True, run_in_background=False)


@app.command()
def start_docker(
    debug: Annotated[bool, typer.Option(help="Start the Docker container in debug mode.")] = False, 
):
    """
    Start a Docker container with the QFlex environment. 
    Useful for development and testing without installing dependencies locally.
    """
    docker_executor = DockerStarter(debug=debug)
    docker_executor.execute(to_stdio=True, run_in_background=False)

# TODO bring in the build scripts here as well


@app.command()
def create_base_image(
    image_name: Annotated[str,typer.Option(
        help="Name of the base image file to create."
    )] = "base.qcow2",
    image_size_gb: Annotated[int, typer.Option(help="Size of the base image in GB.")] = 8 
):
    """
    Create a base image for QEMU. 
    This is the first step to create the images for an experiment.
    """ 
    create_image_executor = CreateImage(image_name=image_name, size_gb=image_size_gb)
    create_image_executor.execute(to_stdio=True, run_in_background=False)

@app.command()
def boot(
    image_name: Annotated[str, typer.Option(
        help="Name of the image file to boot."
    )] = "base.qcow2",
    memory_mb: Annotated[int, typer.Option(help="Memory size for the VM in MB.")] = 2048,
    cores: Annotated[int, typer.Option(help="Number of CPU cores for the VM.")] = 1,
    double_cores: Annotated[bool, typer.Option(help="Double the number of CPU cores.")] = False
):
    """
    Boot a QEMU virtual machine with specified parameters.
    Once booted, you can log in with username 'root' and no password.
    After installing your desired packages and making changes,
    you can save the state with Ctrl+A, then C to create a snapshot named 'base' by savevm base, 
    then exit with Ctrl+C, then quit.
    This is the second step to create the images for an experiment, with all the necessary packages installed.
    """
    boot_executor = Boot(
        image_name=image_name,
        memory_mb=memory_mb,
        cores=cores,
        double_cores=double_cores
    )
    boot_executor.execute(to_stdio=True, run_in_background=False)

@app.command()
def load(
    image_name: Annotated[str, typer.Option(
        help="Name of the image file to load."
    )] = "base.qcow2",
    memory_mb: Annotated[int, typer.Option(help="Memory size for the VM in MB.")] = 2048,
    cores: Annotated[int, typer.Option(help="Number of CPU cores for the VM.")] = 1,
    double_cores: Annotated[bool, typer.Option(help="Double the number of CPU cores.")] = False,
    is_parallel: Annotated[bool, typer.Option(help="Enable parallel execution mode.")] = False,
    quantum_size_ns: Annotated[int, typer.Option(help="Quantum size in nanoseconds.")] = 2000
):
    """
    Load a QEMU virtual machine from a snapshot with specified parameters.
    This is done to warm up long-term microarchitectural state before functional warming starts.
    This is the third step, to prepare for functional warming.
    """
    load_executor = Load(
        image_name=image_name,
        memory_mb=memory_mb,
        cores=cores,
        double_cores=double_cores,
        is_parallel=is_parallel,
        quantum_size_ns=quantum_size_ns
    )
    load_executor.execute(to_stdio=True, run_in_background=False)




if __name__ == "__main__":
    app()